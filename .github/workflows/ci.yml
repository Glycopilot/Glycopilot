name: Deploy to AWS EC2

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

jobs:
  secret-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Install gitleaks
      run: |
        GITLEAKS_VERSION="8.29.0"
        curl -sSL https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_x64.tar.gz -o gitleaks.tar.gz
        tar -xzf gitleaks.tar.gz gitleaks
        sudo mv gitleaks /usr/local/bin/gitleaks
        rm gitleaks.tar.gz
    
    - name: Run gitleaks scan
      run: gitleaks detect --source . --redact --report-path gitleaks-report.json

  test-backend:
    needs: secret-scan
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-django
    
    - name: Run tests with coverage
      env:
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        SECRET_KEY_ADMIN: ${{ secrets.SECRET_KEY_ADMIN }}
        SMTP_HOST: ${{ secrets.SMTP_HOST }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
        SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        SMTP_USE_TLS: ${{ secrets.SMTP_USE_TLS }}
        TESTING: true
      run: |
        cd backend
        pytest --cov=. --cov-report=xml:coverage.xml --cov-report=html
    
    - name: Upload coverage artifact
      uses: actions/upload-artifact@v4
      with:
        name: coverage-backend
        path: backend/coverage.xml
        retention-days: 1
        if-no-files-found: error
    
    - name: Lint with flake8
      run: |
        cd backend
        pip install flake8
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

  sonarqube:
    needs: [test-backend, test-frontend]
    runs-on: ubuntu-latest
    continue-on-error: true  # TODO: Retirer une fois que le coverage sera suffisant
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Download Backend Coverage
      uses: actions/download-artifact@v4
      with:
        name: coverage-backend
        path: backend/
    
    - name: Verify Backend Coverage
      run: |
        if [ -f backend/coverage.xml ]; then
          echo "Backend coverage file found"
          ls -lh backend/coverage.xml
        else
          echo "Backend coverage file not found"
        fi
    
    - name: Download Frontend Coverage
      uses: actions/download-artifact@v4
      with:
        name: coverage-frontend
        path: frontend/coverage/
      continue-on-error: true #a retirer plus tard si on configure les tests frontend
    
    - name: Verify Frontend Coverage
      run: |
        if [ -f frontend/coverage/lcov.info ]; then
          echo "Frontend coverage file found"
          ls -lh frontend/coverage/lcov.info
        else
          echo "Frontend coverage file not found"
        fi
      continue-on-error: true #a retirer plus tard si on configure les tests frontend
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'

    - name: Install frontend dependencies (for tsconfig resolution)
      run: cd frontend && npm install

    - name: Cache SonarCloud packages
      uses: actions/cache@v4
      with:
        path: ~/.sonar/cache
        key: ${{ runner.os }}-sonar-${{ hashFiles('**/sonar-project.properties') }}
        restore-keys: ${{ runner.os }}-sonar-

    - name: SonarCloud Scan
      uses: SonarSource/sonarqube-scan-action@v6
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: https://sonarcloud.io
    
    - name: Wait for SonarCloud Processing
      run: |
        echo "Waiting for SonarCloud to process the analysis..."
        for i in {1..6}; do
          sleep 10
          echo "Waiting... ($i/6)"
        done
    
    - name: Get SonarCloud Project Status
      id: sonar_status
      continue-on-error: true
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        # Récupération du status du Quality Gate avec retry
        for i in {1..3}; do
          RESPONSE=$(curl -s -w "\n%{http_code}" -u "${SONAR_TOKEN}:" \
            "https://sonarcloud.io/api/qualitygates/project_status?projectKey=glycopilot_glycopilot")
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          
          if [ "$HTTP_CODE" -eq 200 ]; then
            QG_STATUS=$(echo "$BODY" | jq -r '.projectStatus.status // "UNKNOWN"')
            echo "quality_gate=$QG_STATUS" >> $GITHUB_OUTPUT
            echo "Quality Gate Status: $QG_STATUS"
            exit 0
          fi
          
          echo "API call failed (attempt $i/3), HTTP $HTTP_CODE"
          [ $i -lt 3 ] && sleep 5
        done
        
        echo "quality_gate=UNKNOWN" >> $GITHUB_OUTPUT
        echo "::warning::Failed to retrieve Quality Gate status from SonarCloud API"
    
    - name: Get SonarCloud Metrics
      id: sonar_metrics
      continue-on-error: true
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        # Récupération des métriques principales avec gestion d'erreur
        RESPONSE=$(curl -s -w "\n%{http_code}" -u "${SONAR_TOKEN}:" \
          "https://sonarcloud.io/api/measures/component?component=glycopilot_glycopilot&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,ncloc")
        
        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
        METRICS=$(echo "$RESPONSE" | head -n-1)
        
        if [ "$HTTP_CODE" -ne 200 ]; then
          echo "::warning::Failed to retrieve metrics from SonarCloud API (HTTP $HTTP_CODE)"
          # Valeurs par défaut
          echo "bugs=N/A" >> $GITHUB_OUTPUT
          echo "vulnerabilities=N/A" >> $GITHUB_OUTPUT
          echo "code_smells=N/A" >> $GITHUB_OUTPUT
          echo "coverage=N/A" >> $GITHUB_OUTPUT
          echo "duplications=N/A" >> $GITHUB_OUTPUT
          echo "lines=N/A" >> $GITHUB_OUTPUT
          echo "backend_coverage=N/A" >> $GITHUB_OUTPUT
          echo "frontend_coverage=N/A" >> $GITHUB_OUTPUT
          echo "uncovered_files={}" >> $GITHUB_OUTPUT
          echo "duplicated_files={}" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        BUGS=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="bugs") | .value // "0"')
        VULNERABILITIES=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="vulnerabilities") | .value // "0"')
        CODE_SMELLS=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="code_smells") | .value // "0"')
        COVERAGE=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="coverage") | .value // "0"')
        DUPLICATIONS=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="duplicated_lines_density") | .value // "0"')
        LINES=$(echo "$METRICS" | jq -r '.component.measures[] | select(.metric=="ncloc") | .value // "0"')
        
        echo "bugs=$BUGS" >> $GITHUB_OUTPUT
        echo "vulnerabilities=$VULNERABILITIES" >> $GITHUB_OUTPUT
        echo "code_smells=$CODE_SMELLS" >> $GITHUB_OUTPUT
        echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
        echo "duplications=$DUPLICATIONS" >> $GITHUB_OUTPUT
        echo "lines=$LINES" >> $GITHUB_OUTPUT
        
        # Récupération de la couverture Backend (Python)
        BACKEND_RESPONSE=$(curl -s -u "${SONAR_TOKEN}:" \
          "https://sonarcloud.io/api/measures/component?component=glycopilot_glycopilot:backend&metricKeys=coverage")
        BACKEND_COVERAGE=$(echo "$BACKEND_RESPONSE" | jq -r '.component.measures[]? | select(.metric=="coverage") | .value // "N/A"')
        echo "backend_coverage=$BACKEND_COVERAGE" >> $GITHUB_OUTPUT
        
        # Récupération de la couverture Frontend (TypeScript/JavaScript)
        FRONTEND_RESPONSE=$(curl -s -u "${SONAR_TOKEN}:" \
          "https://sonarcloud.io/api/measures/component?component=glycopilot_glycopilot:frontend&metricKeys=coverage")
        FRONTEND_COVERAGE=$(echo "$FRONTEND_RESPONSE" | jq -r '.component.measures[]? | select(.metric=="coverage") | .value // "N/A"')
        echo "frontend_coverage=$FRONTEND_COVERAGE" >> $GITHUB_OUTPUT
        
        # Récupération des fichiers non couverts (coverage < 80%)
        UNCOVERED_RESPONSE=$(curl -s -u "${SONAR_TOKEN}:" \
          "https://sonarcloud.io/api/measures/component_tree?component=glycopilot_glycopilot&metricKeys=coverage,uncovered_lines&qualifiers=FIL&ps=500")
        UNCOVERED_FILES=$(echo "$UNCOVERED_RESPONSE" | jq -c '[.components[]? | select(.measures[]? | select(.metric=="coverage" and (.value | tonumber) < 80)) | {path: .path, coverage: (.measures[]? | select(.metric=="coverage") | .value // "0"), uncovered: (.measures[]? | select(.metric=="uncovered_lines") | .value // "0")}] | sort_by(.coverage | tonumber) | .[:10]')
        echo "uncovered_files=$UNCOVERED_FILES" >> $GITHUB_OUTPUT
        
        # Récupération des fichiers dupliqués (duplication > 3%)
        DUPLICATED_RESPONSE=$(curl -s -u "${SONAR_TOKEN}:" \
          "https://sonarcloud.io/api/measures/component_tree?component=glycopilot_glycopilot&metricKeys=duplicated_lines_density,duplicated_lines&qualifiers=FIL&ps=500")
        DUPLICATED_FILES=$(echo "$DUPLICATED_RESPONSE" | jq -c '[.components[]? | select(.measures[]? | select(.metric=="duplicated_lines_density" and (.value | tonumber) > 3)) | {path: .path, duplication: (.measures[]? | select(.metric=="duplicated_lines_density") | .value // "0"), lines: (.measures[]? | select(.metric=="duplicated_lines") | .value // "0")}] | sort_by(.duplication | tonumber) | reverse | .[:10]')
        echo "duplicated_files=$DUPLICATED_FILES" >> $GITHUB_OUTPUT
    
    - name: Create PR Comment Report
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const qualityGate = '${{ steps.sonar_status.outputs.quality_gate }}' || 'UNKNOWN';
          const bugs = '${{ steps.sonar_metrics.outputs.bugs }}' || 'N/A';
          const vulnerabilities = '${{ steps.sonar_metrics.outputs.vulnerabilities }}' || 'N/A';
          const codeSmells = '${{ steps.sonar_metrics.outputs.code_smells }}' || 'N/A';
          const coverage = '${{ steps.sonar_metrics.outputs.coverage }}' || 'N/A';
          const duplications = '${{ steps.sonar_metrics.outputs.duplications }}' || 'N/A';
          const lines = '${{ steps.sonar_metrics.outputs.lines }}' || 'N/A';
          const backendCoverage = '${{ steps.sonar_metrics.outputs.backend_coverage }}' || 'N/A';
          const frontendCoverage = '${{ steps.sonar_metrics.outputs.frontend_coverage }}' || 'N/A';
          
          let uncoveredFiles = [];
          let duplicatedFiles = [];
          
          try {
            uncoveredFiles = JSON.parse('${{ steps.sonar_metrics.outputs.uncovered_files }}' || '[]');
          } catch (e) {
            console.log('Failed to parse uncovered files:', e);
          }
          
          try {
            duplicatedFiles = JSON.parse('${{ steps.sonar_metrics.outputs.duplicated_files }}' || '[]');
          } catch (e) {
            console.log('Failed to parse duplicated files:', e);
          }
          
          const qgText = qualityGate === 'OK' ? 'PASSED' : qualityGate === 'WARN' ? 'WARNING' : qualityGate === 'UNKNOWN' ? 'UNKNOWN' : 'FAILED';
          
          const coverageDisplay = coverage !== 'N/A' ? `${coverage}%` : coverage;
          const duplicationsDisplay = duplications !== 'N/A' ? `${duplications}%` : duplications;
          const backendCoverageDisplay = backendCoverage !== 'N/A' ? `${backendCoverage}%` : backendCoverage;
          const frontendCoverageDisplay = frontendCoverage !== 'N/A' ? `${frontendCoverage}%` : frontendCoverage;
          
          // Construction de la section des fichiers non couverts
          let uncoveredSection = '';
          if (uncoveredFiles.length > 0) {
            uncoveredSection = '\n### Fichiers avec couverture insuffisante (<80%)\n\n';
            uncoveredSection += '| Fichier | Couverture | Lignes non couvertes |\n';
            uncoveredSection += '|---------|------------|----------------------|\n';
            uncoveredFiles.forEach(file => {
              const shortPath = file.path.length > 50 ? '...' + file.path.slice(-47) : file.path;
              uncoveredSection += `| \`${shortPath}\` | ${file.coverage}% | ${file.uncovered} |\n`;
            });
          }
          
          // Construction de la section des fichiers dupliqués
          let duplicatedSection = '';
          if (duplicatedFiles.length > 0) {
            duplicatedSection = '\n### Fichiers avec code dupliqué (>3%)\n\n';
            duplicatedSection += '| Fichier | Duplication | Lignes dupliquées |\n';
            duplicatedSection += '|---------|-------------|-------------------|\n';
            duplicatedFiles.forEach(file => {
              const shortPath = file.path.length > 50 ? '...' + file.path.slice(-47) : file.path;
              duplicatedSection += `| \`${shortPath}\` | ${file.duplication}% | ${file.lines} |\n`;
            });
          }
          
          const report = `## Rapport SonarCloud
          
          **Quality Gate:** ${qgText}
          
          ### Métriques globales
          
          | Métrique | Valeur | Détails |
          |----------|--------|----------|
          | Bugs | **${bugs}** | Problèmes qui représentent des erreurs de code |
          | Vulnérabilités | **${vulnerabilities}** | Failles de sécurité potentielles |
          | Code Smells | **${codeSmells}** | Problèmes de maintenabilité |
          | Coverage globale | **${coverageDisplay}** | Couverture de code par les tests |
          | Duplications | **${duplicationsDisplay}** | Code dupliqué |
          | Lignes de code | **${lines}** | Nombre de lignes (sans commentaires) |
          
          ### Couverture par composant
          
          | Composant | Couverture |
          |-----------|------------|
          | **Backend** (Python) | **${backendCoverageDisplay}** |
          | **Frontend** (TypeScript/JS) | **${frontendCoverageDisplay}** |
          ${uncoveredSection}
          ${duplicatedSection}
          
          ### Liens utiles
          
          - [Dashboard complet](https://sonarcloud.io/summary/overall?id=glycopilot_glycopilot)
          - [Liste des bugs](https://sonarcloud.io/project/issues?resolved=false&types=BUG&id=glycopilot_glycopilot)
          - [Vulnérabilités](https://sonarcloud.io/project/security_hotspots?id=glycopilot_glycopilot)
          - [Code Coverage](https://sonarcloud.io/component_measures?metric=coverage&id=glycopilot_glycopilot)
          - [Code duplications](https://sonarcloud.io/component_measures?metric=duplicated_lines_density&id=glycopilot_glycopilot)
          
          ---
          
          ${qualityGate !== 'OK' ? '**Note:** Le Quality Gate est temporairement en mode \`continue-on-error\` pendant le développement actif.' : ''}
          `;
          
          // Chercher si un commentaire existe déjà
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && comment.body.includes('Rapport SonarCloud')
          );
          
          if (botComment) {
            // Mettre à jour le commentaire existant
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: report
            });
          } else {
            // Créer un nouveau commentaire
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: report
            });
          }
    
    - name: Check Quality Gate Status
      run: |
        echo "::warning title=SonarQube Quality Gate::Le Quality Gate peut échouer en raison d'une couverture de code insuffisante. Ceci est temporaire pendant le développement."
        echo "SonarCloud analysis completed"
        echo "ATTENTION: continue-on-error est activé temporairement"
        echo "Le Quality Gate devrait passer une fois le code et les tests complétés"

  test-frontend:
    needs: secret-scan
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
    
    - name: Install dependencies
      run: |
        cd frontend
        npm install
    
    - name: Run tests with coverage
      run: |
        cd frontend
        npm test -- --coverage --watchAll=false || echo "No tests configured"
    
    - name: Upload coverage artifact
      uses: actions/upload-artifact@v4
      with:
        name: coverage-frontend
        path: frontend/coverage/
        retention-days: 1
        if-no-files-found: ignore
      continue-on-error: true #a retirer plus tard si on configure les tests frontend

  deploy:
    needs: [test-backend, test-frontend, sonarqube]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' 
    steps:
    - uses: actions/checkout@v4
    
    - name: Copy files to EC2
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        source: "."
        target: "/var/www/glycopilot_app"
        rm: false
    
    - name: Deploy to AWS EC2
      uses: appleboy/ssh-action@master
      env:
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        SECRET_KEY_ADMIN: ${{ secrets.SECRET_KEY_ADMIN }}
        ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        SMTP_HOST: ${{ secrets.SMTP_HOST }}
        SMTP_PORT: ${{ secrets.SMTP_PORT }}
        SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
        SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        SMTP_USE_TLS: ${{ secrets.SMTP_USE_TLS }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_STORAGE_BUCKET_NAME: ${{ secrets.AWS_STORAGE_BUCKET_NAME }}
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        envs: SECRET_KEY,SECRET_KEY_ADMIN,ALLOWED_HOSTS,DB_PASSWORD,SMTP_HOST,SMTP_PORT,SMTP_USERNAME,SMTP_PASSWORD,SMTP_USE_TLS,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_STORAGE_BUCKET_NAME
        script: |
          cd /var/www/glycopilot_app
          
          cat > .env << EOF
          DEBUG=False
          SECRET_KEY=${SECRET_KEY}
          SECRET_KEY_ADMIN=${SECRET_KEY_ADMIN}
          ALLOWED_HOSTS=${ALLOWED_HOSTS}
          DB_ENGINE=postgresql
          DB_NAME=django_db
          DB_USER=django_user
          DB_PASSWORD=${DB_PASSWORD}
          DB_HOST=localhost
          DB_PORT=5432
          SMTP_HOST=${SMTP_HOST}
          SMTP_PORT=${SMTP_PORT}
          SMTP_USERNAME=${SMTP_USERNAME}
          SMTP_PASSWORD=${SMTP_PASSWORD}
          SMTP_USE_TLS=${SMTP_USE_TLS}
          AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
          AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
          AWS_STORAGE_BUCKET_NAME=${AWS_STORAGE_BUCKET_NAME}
          AWS_S3_REGION_NAME=eu-west-3
          EOF
          
          chmod +x deploy.sh
          ./deploy.sh

  notify:
    needs: [secret-scan, test-backend, test-frontend, sonarqube, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Pipeline Summary
      run: |
        echo "======================================"
        echo "PIPELINE SUMMARY"
        echo "======================================"
        echo "Branch: ${{ github.ref_name }}"
        echo "Commit: ${{ github.sha }}"
        echo "Triggered by: ${{ github.actor }}"
        echo ""
        echo "======================================"
        echo "Job Status:"
        echo "======================================"
        echo "Secret Scan: ${{ needs.secret-scan.result }}"
        echo "Backend Tests: ${{ needs.test-backend.result }}"
        echo "Frontend Tests: ${{ needs.test-frontend.result }}"
        echo "SonarQube: ${{ needs.sonarqube.result }}"
        echo "Deploy: ${{ needs.deploy.result }}"
        echo "======================================"
        echo ""
        
        # Résumé des résultats (informatif uniquement, ne fait pas échouer la pipeline)
        CRITICAL_FAILED=false
        
        # Vérifier les jobs critiques
        if [ "${{ needs.secret-scan.result }}" != "success" ]; then
          echo "CRITICAL: Secret scan failed"
          CRITICAL_FAILED=true
        fi
        
        if [ "${{ needs.test-backend.result }}" != "success" ]; then
          echo "CRITICAL: Backend tests failed"
          CRITICAL_FAILED=true
        fi
        
        if [ "${{ needs.test-frontend.result }}" != "success" ]; then
          echo "CRITICAL: Frontend tests failed"
          CRITICAL_FAILED=true
        fi
        
        # Informations sur les jobs non-critiques
        if [ "${{ needs.sonarqube.result }}" != "success" ]; then
          echo "INFO: SonarQube analysis completed with issues (temporarily allowed)"
        fi
        
        if [ "${{ needs.deploy.result }}" == "failure" ]; then
          echo "WARNING: Deployment failed"
        elif [ "${{ needs.deploy.result }}" == "skipped" ]; then
          echo "INFO: Deployment skipped (not on main branch)"
        elif [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "SUCCESS: Deployment completed"
        fi
        
        echo ""
        echo "======================================"
        
        # Résumé final
        if [ "$CRITICAL_FAILED" = true ]; then
          echo "FINAL STATUS: FAILED - Critical quality checks did not pass"
          echo "The pipeline is marked as failed by the failed jobs themselves"
        else
          echo "FINAL STATUS: SUCCESS - All critical quality checks passed"
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "Application deployed successfully"
          fi
        fi
        
        echo "======================================"
        echo ""
        echo "Note: This notification job does not affect the pipeline status."
        echo "The actual pipeline status is determined by the individual jobs."
